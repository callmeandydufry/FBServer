/*$T Share/GameUtil.h GC 1.140 10/10/07 10:06:30 */


/*$6
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */


#ifndef __GAMEUTIL_H__
#define __GAMEUTIL_H__

#include "TypeDefine.h"
#include "Define.h"
#include "KwNetStreamSystem.h"
#include "ModuleDataStream.h"
#if defined(__LINUX__)
#include <iconv.h>
#endif

#define __PI		3.1415f
#define __HALF_PI	__PI / 2
#define __QUARTER_PI	__PI / 4

#define THREAD_CAPS	(512)

class	ThreadIndent
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	ThreadIndent();
	~	ThreadIndent();

	void	AddThread(TID tid);

	void	SetThreadIndent(TID tid, int32 nValue);
	int32	GetThreadIndent(TID tid);

	TID	m_ThreadID[THREAD_CAPS];
	int32	m_ThreadIndent[THREAD_CAPS];
};

extern ThreadIndent	g_ThreadIndent;

TID			KGetCurrentTID();
TID			GetOrigineThreadID();
uint32			MyGetCurrentPID();

#if defined(__WINDOWS__)
class			FastLock
{
	CRITICAL_SECTION	m_Lock;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	mStatus;

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	FastLock()
	{
		InitializeCriticalSection(&m_Lock);
		mStatus = FALSE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~FastLock()
	{
		DeleteCriticalSection(&m_Lock);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Lock()
	{
		EnterCriticalSection(&m_Lock);
#if defined(__WINDOWS__)
		if(mStatus)
		{
			KCheck(FALSE);
		}
#endif
		mStatus = TRUE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Unlock()
	{
		mStatus = FALSE;
		LeaveCriticalSection(&m_Lock);
	};
};
#elif defined(__LINUX__)
class	FastLock
{
	pthread_mutex_t m_Mutex;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	mStatus;

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	FastLock()
	{
		pthread_mutex_init(&m_Mutex, NULL);
		mStatus = FALSE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~FastLock()
	{
		pthread_mutex_destroy(&m_Mutex);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Lock()
	{
		pthread_mutex_lock(&m_Mutex);
		mStatus = TRUE;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Unlock()
	{
		pthread_mutex_unlock(&m_Mutex);
		mStatus = FALSE;
	};
	
	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void lock()
	{
		pthread_mutex_lock(&m_Mutex);
		mStatus = TRUE;
	};
	
	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void unlock()
	{
		pthread_mutex_unlock(&m_Mutex);
		mStatus = FALSE;
	};
};
#endif

// 该类与IOS系统类库名字与功能冲突
#if !defined(IOS)
template<typename Mutex>
class lock_guard
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	Mutex			&m;

	explicit		lock_guard(lock_guard &);
	lock_guard &operator	=(lock_guard &);

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	explicit lock_guard(Mutex &m_) :
	m(m_)
	{
		m.Lock();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~lock_guard(void)
	{
		m.Unlock();
	}
};
#endif // !defined(IOS)

class	CTinyTimer
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	uint32	m_uTickTerm;
	uint32	m_uTickOld;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	BOOL	m_bOper;

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	CTinyTimer()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL IsSetTimer()
	{
		return m_bOper;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void SetTermTime(uint32 uTerm)
	{
		m_uTickTerm = uTerm;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetTermTime()
	{
		return m_uTickTerm;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetTickOldTime()
	{
		return m_uTickOld;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uTickTerm = 0;
		m_bOper = FALSE;
		m_uTickOld = 0;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void BeginTimer(uint32 uTerm, uint32 uNow)
	{
		m_bOper = TRUE;
		m_uTickTerm = uTerm;
		m_uTickOld = uNow;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL CountingTimer(uint32 uNow)
	{
		if(!m_bOper) return FALSE;

		/*~~~~~~~~~~~~~~~~*/
		uint32	uNew = uNow;
		uint32	uDelta = 0;
		/*~~~~~~~~~~~~~~~~*/

		if(uNew >= m_uTickOld)
		{
			uDelta = uNew - m_uTickOld;
		}
		else
		{
			if((uNew + 10000) < m_uTickOld)
			{
				uDelta = ((uint32) 0xFFFFFFFF - m_uTickOld) + uNew;
			}
			else
			{
				return FALSE;
			}
		}

		if(uDelta < m_uTickTerm)
		{
			return FALSE;
		}

		m_uTickOld = uNew;

		return TRUE;
	}
};

extern void	SafeSleep(uint32 millionseconds = 0);

extern TID	KGetCurrentTID();
extern TID	GetOrigineThreadID();

extern char	*KLSocketError();

extern uint32	KLCRC(const char *szString);

/*
 =======================================================================================================================
 =======================================================================================================================
 */

template<class T>
int32 Float2Int(T TValue)
{
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	int32	iValue = (int32) TValue;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	if(TValue - iValue < 0.500000f)
	{
		return iValue;
	}
	else
		return iValue + 1;
}

struct BigInt
{
	int32	m_uLowInt;
	uint32	m_uHighInt;

	BigInt()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLowInt = 0;
		m_uHighInt = 0;
	}
};

struct Flag32
{
	uint32	m_wFlags;

	Flag32()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(m_wFlags & (1 << bit)) return TRUE;

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bUpdate)
			m_wFlags |= (1 << bit);
		else
			m_wFlags &= (~(1 << bit));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	static uint32 GetMsgSize()
	{
		return sizeof(uint32);
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Reci(RecieveStream &iStream)
	{
		iStream.Reci((char *) &m_wFlags, sizeof(m_wFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Send(SendStream &oStream) const
	{
		oStream.Send((char *) &m_wFlags, sizeof(m_wFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_wFlags = 0;
	};
};

struct SFlag64
{
	uint32	m_uLowFlags;
	uint32	m_uHighFlags;

	SFlag64()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_uLowFlags & (1 << bit)) return TRUE;
		}
		else
		{
			if(m_uHighFlags & (1 << (bit - 32))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_uLowFlags |= (1 << (int32) bit);
			else
				m_uLowFlags &= (~(1 << (int32) bit));
		}
		else
		{
			if(bUpdate)
				m_uHighFlags |= (1 << (int32) (bit - 32));
			else
				m_uHighFlags &= (~(1 << (int32) (bit - 32)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_uLowFlags) + sizeof(m_uHighFlags);
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reci(RecieveStream &iStream)
	{
		iStream.Reci((char *) &m_uLowFlags, sizeof(m_uLowFlags));
		iStream.Reci((char *) &m_uHighFlags, sizeof(m_uHighFlags));
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Send(SendStream &oStream) const
	{
		oStream.Send((char *) &m_uLowFlags, sizeof(m_uLowFlags));
		oStream.Send((char *) &m_uHighFlags, sizeof(m_uHighFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLowFlags = 0;
		m_uHighFlags = 0;
	}
};

struct Flag128
{
	uint32	m_uLLowFlags;
	uint32	m_uLHighFlags;
	uint32	m_uHLowFlags;
	uint32	m_uHHighFlags;

	Flag128()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_uLLowFlags & (1 << bit)) return TRUE;
		}
		else if(bit < 64)
		{
			if(m_uLHighFlags & (1 << (bit - 32))) return TRUE;
		}
		else if(bit < 96)
		{
			if(m_uHLowFlags & (1 << (bit - 64))) return TRUE;
		}
		else if(bit < 128)
		{
			if(m_uHHighFlags & (1 << (bit - 96))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_uLLowFlags |= (1 << (int32) bit);
			else
				m_uLLowFlags &= (~(1 << (int32) bit));
		}
		else if(bit < 64)
		{
			if(bUpdate)
				m_uLHighFlags |= (1 << (int32) (bit - 32));
			else
				m_uLHighFlags &= (~(1 << (int32) (bit - 32)));
		}
		else if(bit < 96)
		{
			if(bUpdate)
				m_uHLowFlags |= (1 << (int32) (bit - 64));
			else
				m_uHLowFlags &= (~(1 << (int32) (bit - 64)));
		}
		else if(bit < 128)
		{
			if(bUpdate)
				m_uHHighFlags |= (1 << (int32) (bit - 96));
			else
				m_uHHighFlags &= (~(1 << (int32) (bit - 96)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_uLLowFlags) + sizeof(m_uLHighFlags) + sizeof(m_uHLowFlags) + sizeof(m_uHHighFlags) ;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reci(RecieveStream &iStream)
	{
		iStream.Reci((char *) &m_uLLowFlags, sizeof(m_uLLowFlags));
		iStream.Reci((char *) &m_uLHighFlags, sizeof(m_uLHighFlags));
		iStream.Reci((char *) &m_uHLowFlags, sizeof(m_uHLowFlags));
		iStream.Reci((char *) &m_uHHighFlags, sizeof(m_uHHighFlags));

	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Send(SendStream &oStream) const
	{
		oStream.Send((char *) &m_uLLowFlags, sizeof(m_uLLowFlags));
		oStream.Send((char *) &m_uLHighFlags, sizeof(m_uLHighFlags));
		oStream.Send((char *) &m_uHLowFlags, sizeof(m_uHLowFlags));
		oStream.Send((char *) &m_uHHighFlags, sizeof(m_uHHighFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_uLLowFlags = 0;
		m_uLHighFlags = 0;
		m_uHLowFlags = 0;
		m_uHHighFlags = 0;
	}
};

struct Flag256
{
	uint32	m_u32Flags;
	uint32	m_u64Flags;
	uint32	m_u96Flags;
	uint32	m_u128Flags;
	uint32	m_u160Flags;
	uint32	m_u192Flags;
	uint32	m_u224Flags;
	uint32	m_u256Flags;

	Flag256()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(bit < 32)
		{
			if(m_u32Flags & (1 << bit)) return TRUE;
		}
		else if(bit < 64)
		{
			if(m_u64Flags & (1 << (bit - 32))) return TRUE;
		}
		else if(bit < 96)
		{
			if(m_u96Flags & (1 << (bit - 64))) return TRUE;
		}
		else if(bit < 128)
		{
			if(m_u128Flags & (1 << (bit - 96))) return TRUE;
		}
		else if(bit < 160)
		{
			if(m_u160Flags & (1 << (bit - 128))) return TRUE;
		}
		else if(bit < 192)
		{
			if(m_u192Flags & (1 << (bit - 160))) return TRUE;
		}
		else if(bit < 224)
		{
			if(m_u224Flags & (1 << (bit - 192))) return TRUE;
		}
		else if(bit < 256)
		{
			if(m_u256Flags & (1 << (bit - 224))) return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bit < 32)
		{
			if(bUpdate)
				m_u32Flags |= (1 << (int32) bit);
			else
				m_u32Flags &= (~(1 << (int32) bit));
		}
		else if(bit < 64)
		{
			if(bUpdate)
				m_u64Flags |= (1 << (int32) (bit - 32));
			else
				m_u64Flags &= (~(1 << (int32) (bit - 32)));
		}
		else if(bit < 96)
		{
			if(bUpdate)
				m_u96Flags |= (1 << (int32) (bit - 64));
			else
				m_u96Flags &= (~(1 << (int32) (bit - 64)));
		}
		else if(bit < 128)
		{
			if(bUpdate)
				m_u128Flags |= (1 << (int32) (bit - 96));
			else
				m_u128Flags &= (~(1 << (int32) (bit - 96)));
		}
		else if(bit < 160)
		{
			if(bUpdate)
				m_u160Flags |= (1 << (int32) (bit - 128));
			else
				m_u160Flags &= (~(1 << (int32) (bit - 128)));
		}
		else if(bit < 192)
		{
			if(bUpdate)
				m_u192Flags |= (1 << (int32) (bit - 160));
			else
				m_u192Flags &= (~(1 << (int32) (bit - 160)));
		}
		else if(bit < 224)
		{
			if(bUpdate)
				m_u224Flags |= (1 << (int32) (bit - 192));
			else
				m_u224Flags &= (~(1 << (int32) (bit - 192)));
		}
		else if(bit < 256)
		{
			if(bUpdate)
				m_u256Flags |= (1 << (int32) (bit - 224));
			else
				m_u256Flags &= (~(1 << (int32) (bit - 224)));
		}
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetMsgSize() const
	{
		return sizeof(m_u32Flags) + 
			sizeof(m_u64Flags) + 
			sizeof(m_u96Flags) +
			sizeof(m_u128Flags) +
			sizeof(m_u160Flags) + 
			sizeof(m_u192Flags) +
			sizeof(m_u224Flags) +
			sizeof(m_u256Flags)	;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reci(RecieveStream &iStream)
	{
		iStream.Reci((char *) &m_u32Flags, sizeof(m_u32Flags));
		iStream.Reci((char *) &m_u64Flags, sizeof(m_u64Flags));
		iStream.Reci((char *) &m_u96Flags, sizeof(m_u96Flags));
		iStream.Reci((char *) &m_u128Flags, sizeof(m_u128Flags));
		iStream.Reci((char *) &m_u160Flags, sizeof(m_u160Flags));
		iStream.Reci((char *) &m_u192Flags, sizeof(m_u192Flags));
		iStream.Reci((char *) &m_u224Flags, sizeof(m_u224Flags));
		iStream.Reci((char *) &m_u256Flags, sizeof(m_u256Flags));
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Send(SendStream &oStream) const
	{
		oStream.Send((char *) &m_u32Flags, sizeof(m_u32Flags));
		oStream.Send((char *) &m_u64Flags, sizeof(m_u64Flags));
		oStream.Send((char *) &m_u96Flags, sizeof(m_u96Flags));
		oStream.Send((char *) &m_u128Flags, sizeof(m_u128Flags));
		oStream.Send((char *) &m_u160Flags, sizeof(m_u160Flags));
		oStream.Send((char *) &m_u192Flags, sizeof(m_u192Flags));
		oStream.Send((char *) &m_u224Flags, sizeof(m_u224Flags));
		oStream.Send((char *) &m_u256Flags, sizeof(m_u256Flags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_u32Flags = 0;
		m_u64Flags = 0;
		m_u96Flags = 0;
		m_u128Flags = 0;
		m_u160Flags = 0;
		m_u192Flags = 0;
		m_u224Flags = 0;
		m_u256Flags = 0;
	}
};

#define SM_FREE		(-1)
#define SM_C_READ	0x01
#define SM_C_WRITE	0x02
#define SM_S_READ	0x03
#define SM_S_WRITE	0x04
#define SM_W_READ	0x05
#define SM_W_WRITE	0x06

void	shm_lock(atword *flag, char type);
void	shm_unlock(atword *flag, char type);
void	shm_tryunlock(atword *flag, char type);

#define SHM_LOCK(flag, type)	shm_lock(flag, type);
#define SHM_UNLOCK(flag, type)	shm_unlock(flag, type);

struct SFlag16
{
	uint16	m_wFlags;

	SFlag16()
	{
		Clear();
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL isSetBit(int32 bit) const
	{
		if(m_wFlags & (1 << bit)) return TRUE;

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void UpdateBits(int32 bit, BOOL bUpdate)
	{
		if(bUpdate)
			m_wFlags |= (1 << bit);
		else
			m_wFlags &= (~(1 << bit));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetMsgSize() const
	{
		return sizeof(m_wFlags);
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Reci(RecieveStream &iStream)
	{
		iStream.Reci((char *) &m_wFlags, sizeof(m_wFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Send(SendStream &oStream) const
	{
		oStream.Send((char *) &m_wFlags, sizeof(m_wFlags));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear()
	{
		m_wFlags = 0;
	};
};

template<uint32 nSize>
class BitFlags
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BitFlags(void)
	{
		memset((void *) m_aBitFlags, '\0', sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BitFlags(BitFlags const &rhs)
	{
		memcpy((void *) m_aBitFlags, (void *) (rhs.GetFlags()), sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~BitFlags()
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BitFlags &operator=(BitFlags const &rhs)
	{
		memcpy((void *) m_aBitFlags, (void *) (rhs.GetFlags()), sizeof(m_aBitFlags));
		return *this;
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	void MarkAllFlags(void)
	{
		memset((void *) m_aBitFlags, 0xFF, sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	void ClearAllFlags(void)
	{
		memset((void *) m_aBitFlags, 0x00, sizeof(m_aBitFlags));
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BOOL GetFlagByIndex(int32 const nIdx) const
	{
		if(0 > nIdx || BF_BIT_SIZE<= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::GetFlagByIndex]: Index out of range!");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~~~~*/
		uint32	nIndex = nIdx;
		/*~~~~~~~~~~~~~~~~~~*/

		return 0 != (m_aBitFlags[nIdx >> 3] & (char) (1 << nIdx % 8));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void Clear_FlagByIndex(int32 const nIdx)
	{
		if(0 > nIdx || BF_BIT_SIZE <= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::Clear_FlagByIndex]: Index out of range!");
			return;
		}

		m_aBitFlags[nIdx >> 3] &= ~(0x01 << (nIdx % 8));
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void MarkFlagByIndex(int32 const nIdx)
	{
		if(0 > nIdx || BF_BIT_SIZE <= nIdx)
		{
			KCheckEx(FALSE, "[BitFlags::MarkFlagByIndex]: Index out of range!");
			return;
		}

		m_aBitFlags[nIdx >> 3] |= 0x01 << (nIdx % 8);
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	void MergeFlag(BitFlags const &rhs)
	{
		char const *const rhsBits = rhs.GetFlags();
		for(int32 i = 0; i < BF_BYTE_SIZE; ++i)
		{
			m_aBitFlags[i] |= rhsBits[i];
		}
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetByteSize(void) const
	{
		return BF_BYTE_SIZE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetBitSize(void) const
	{
		return BF_BIT_SIZE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	char const *const GetFlags(void) const
	{
		return m_aBitFlags;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	BOOL HasAnyMarkedFlag()
	{
		for (int32 i = 0; i < BF_BYTE_SIZE; ++i)
		{
			if (m_aBitFlags[i] != 0)
			{
				return TRUE;
			}
		}
		return FALSE;
	}

	BOOL serialize(DataStream &oStream) const
	{
		oStream.serialize(m_aBitFlags, sizeof(m_aBitFlags));
		return TRUE;
	}

	BOOL unserialize(DataStream &iStream)
	{
		iStream.unserialize(m_aBitFlags, sizeof(m_aBitFlags));
		return TRUE;
	}

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
	enum { BF_BIT_SIZE = nSize, BF_BYTE_SIZE = 1 + BF_BIT_SIZE / 8, };
	
private:
	char	m_aBitFlags[BF_BYTE_SIZE];
};
template<typename U, size_t nSizeLimit>
class KLVector
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:
	enum { SIZE_LIMIT = nSizeLimit, };

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	KLVector(void) :
	m_nCurrentSize(0),
	m_pUnits(NULL)
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~KLVector()
	{
		KSafeDelete_ARRAY(m_pUnits);
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */

	BOOL Init(size_t nSize)
	{
		if(NULL != m_pUnits)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Init a Used vector!!Check it now.");
			return FALSE;
		}

		if(SIZE_LIMIT < nSize)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Size over flow!! check it now.");
			return FALSE;
		}

		m_pUnits = new U[nSize];
		if(NULL == m_pUnits)
		{
			KCheckEx(FALSE, "[KLVector::Init]: Allocate memory Failed!!Check it now.");
			return FALSE;
		}

		m_nCurrentSize = nSize;
		return TRUE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL Resize(size_t nSize)
	{
		if(SIZE_LIMIT < nSize)
		{
			KCheckEx(FALSE, "[KLVector::Resize]: Size over flow!! check it now.");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		U	*pNewBlock = new U[nSize];
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		if(NULL == pNewBlock)
		{
			KCheckEx(FALSE, "[KLVector::Resize]: new memory Failed!!Check it now.");
			return FALSE;
		}

		/*~~~~~~~~~~~~~~~*/
		size_t	nCount = 0;
		/*~~~~~~~~~~~~~~~*/

		if(m_nCurrentSize > nSize)
		{
			nCount = nSize;
		}
		else
		{
			nCount = m_nCurrentSize;
		}

		memcpy((void *) pNewBlock, (void const *) m_pUnits, sizeof(U) * nCount);

		KSafeDelete_ARRAY(m_pUnits);

		m_pUnits = pNewBlock;

		m_nCurrentSize = nSize;
		return TRUE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	U const *GetUnitByIndex(size_t nIdx) const
	{
		if(0 <= nIdx && m_nCurrentSize > nIdx)
		{
			return m_pUnits[nIdx];
		}

		return NULL;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	BOOL SetUnitByIndex(size_t nIdx, U const &rU)
	{
		if(0 <= nIdx && m_nCurrentSize > nIdx)
		{
			m_pUnits[nIdx] = rU;
			return TRUE;
		}

		return FALSE;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	size_t GetCurVectorSize(void) const
	{
		return m_nCurrentSize;
	}

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	uint32 GetByteSize(void) const
	{
		return sizeof(U) * m_nCurrentSize;
	}

/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
protected:
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
private:
	size_t	m_nCurrentSize;
	U	*m_pUnits;
};

#if defined(__WINDOWS__)
#define tvsnprintf	_vsnprintf
#define tstricmp	_stricmp
#define tsnprintf	_snprintf
#elif defined(__LINUX__)
#define tvsnprintf	vsnprintf
#define tstricmp	strcasecmp
#define tsnprintf	snprintf
#endif
char			Data2Ascii(char in);
char			Ascii2Data(char in);

BOOL			CharToString(const char *pIn, uint32 InLength, char *pOut);
BOOL			StringToChar(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit, uint32 &OutLength);
BOOL			Binary2Str(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit);
BOOL			Str2Binary(const char *pIn, uint32 InLength, char *pOut, uint32 OutLimit, uint32 &OutLength);
BOOL			CheckStr(const char *pIn, uint32 InLength);
void			ODBCEscapeString(const char *in, uint32 len, char *out);
char			MyToLower(char c);
void			StringLower(char *pStr);

uint32			GetValueByBit(uint32 nDataValue, int32 nOffset, int32 nSize);
uint32			SetValueByBit(uint32 nDataValue, int32 nOffset, int32 nSize, int32 nValue);

void			tsnprintf_s(char *buffer, size_t count, const char *format, ...);

void			StackDump(const char *type);

BOOL			ReachTime(uint32 desttime, uint32 now);

uint32			CRC(const char *szBuff, int32 nLen);
uint32			CheckSum(const char *szBuff, int32 nLen);
uint64			StrToUINT64(const char *szBuff);
void			PrintU64(uint64 value);
uint32			GetHighSection(uint64 uValue);			
uint32			GetLowSection(uint64 uValue);
uint64			ToUint64(uint32 uHigh, uint32 uLow);

BOOL			GetStrIP(IP_t IP, char *szIP);

BOOL			CheckAlphaNumFilter(const char* pStr);
BOOL			CheckIsANumString(const char* pStr);

//编码，参数：要编码的字符串指针，解码后存放的位置（编码字串长度的4/3），要编码的字符串长度 ->返回结果长度  
int Base64Encode(char *lpBuffer, const char *lpString, int sLen);
//解码，参数：结果，密文，密文长度  
int Base64Decode(char *lpBuffer, const char *lpSrc, int sLen);

// Url字符串的转码与解码，转码的时候注意dest的长度应为src长度3倍 [4/27/2015 yangzhen]
int32 UrlEncode(const char* szSrc, uint32 uSrcLen, char* szDest, uint32 uDestLen);
int32 UrlDecode(const char* szSrc, uint32 uSrcLen, char* szDest, uint32 uDestLen);

//  (_start, _end] 左开右闭
extern bool IntIsBetweenlR(int x, int _start, int _end);
//  (_start, _end) 左开右开
extern bool IntIsBetweenlr(int x, int _start, int _end);
//  [_start, _end) 左闭右开
extern bool IntIsBetweenLr(int x, int _start, int _end);
//  [_start, _end] 左闭右闭
extern bool IntIsBetweenLR(int x, int _start, int _end);


struct SRandomTab
{
	enum { max_record_num = 100000 };
	uint32 m_uCurPoint;
	uint32 m_uRecord[max_record_num];

	SRandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++) m_uRecord[_Idx] =
			rand()
			* rand();

		m_uCurPoint = 0;
	}
};

struct KL100RandomTab
{
	enum { max_record_num = 100 };

	uint32 m_uRecord[max_record_num];
	uint32 m_uCurPoint;

	KL100RandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++) m_uRecord[_Idx] = _Idx;

		Reset();
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reset()
	{
		for(int32 _Idx = 0; _Idx < 100; _Idx++)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			uint32	uFrom = rand() % max_record_num;
			uint32	uToIndex = rand() % max_record_num;
			uint32	uBuf = m_uRecord[uToIndex];
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			m_uRecord[uToIndex] = m_uRecord[uFrom];
			m_uRecord[uFrom] = uBuf;
		}

		m_uCurPoint = 0;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetRand()
	{
		if(m_uCurPoint >= max_record_num) Reset();

		return m_uRecord[m_uCurPoint++];
	}
};

struct KL1000RandomTab
{
	enum { max_record_num = 1000 };

	uint32 m_uRecord[max_record_num];
	uint32 m_uCurPoint;

	KL1000RandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++) m_uRecord[_Idx] = _Idx;

		Reset();
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reset()
	{
		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			uint32	uFrom = rand() % max_record_num;
			uint32	uToIndex = rand() % max_record_num;
			uint32	uBuf = m_uRecord[uToIndex];
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			m_uRecord[uToIndex] = m_uRecord[uFrom];
			m_uRecord[uFrom] = uBuf;
		}

		m_uCurPoint = 0;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetRand()
	{
		if(m_uCurPoint >= max_record_num) Reset();

		return m_uRecord[m_uCurPoint++];
	}
};

//假随机算法，保证每个数字一定出现且仅出现一次
struct KL10000RandomTab
{
	enum { max_record_num = 10000 };

	uint32 m_uRecord[max_record_num];
	uint32 m_uCurPoint;

	KL10000RandomTab()
	{
		srand((unsigned) time(NULL));

		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++) m_uRecord[_Idx] = _Idx;

		Reset();
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void Reset()
	{
		for(int32 _Idx = 0; _Idx < max_record_num; _Idx++)
		{
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			uint32	uFrom = rand() % max_record_num;
			uint32	uToIndex = rand() % max_record_num;
			uint32	uBuf = m_uRecord[uToIndex];
			/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

			m_uRecord[uToIndex] = m_uRecord[uFrom];
			m_uRecord[uFrom] = uBuf;
		}

		m_uCurPoint = 0;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	uint32 GetRand()
	{
		if(m_uCurPoint >= max_record_num) Reset();

		return m_uRecord[m_uCurPoint++];
	}
};

class	KLRandom
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:
	KLRandom();
	~		KLRandom();

	static void	SetRand(uint32 uKey);

	static uint32	Rand();

#define MAX_KEY_SIZE	100000
	static char	m_pKey[MAX_KEY_SIZE];
	static uint32	m_uKey;
	static FastLock m_Lock;
};
class	RandGenerator
{
	static const uint32	Max32BitLong = 0xFFFFFFFFLU;

	static const uint32	RandomMax = Max32BitLong;

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	RandGenerator(const uint32 Seed = 0)
	{
		SetRandSeed(Seed);
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	void SetRandSeed(const uint32 Seed)
	{
		srand(Seed);
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	unsigned long RandUInt(void)
	{
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
		uint32	inta = (rand() & 0x00000FFF);
		uint32	intb = ((rand() & 0x00000FFF) << 12);
		uint32	intc = ((rand() & 0x000000FF) << 24);
		uint32	intd = inta + intb + intc;
		/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

		return intd;
	}

	/*
	===============================================================================================================
	===============================================================================================================
	*/
	float64 RandDouble(void)
	{
		return static_cast<float64>(RandUInt()) / (static_cast<float64>(RandomMax));
	}

	static uint32	GetRand(int32 nStart, int32 nEnd);
};

extern RandGenerator	g_RandGenerator;
class		SeedRand
{
	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
public:
	SeedRand();
	~		SeedRand();

	void		SetSeed(int32 seed);
	int32		Rand();

	int32		GetSeed();

	static int32	GetRandByKey(int32 seed, int32 key);
	static int32	GetKeyByRand(int32 seed, int32 rand);

	/*
	-----------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------------------------------------------------
	*/
private:
	int32	holdrand;
	int32	seed;
};


#if defined(_70_WORLD)
class			MyDecoder
{
/*
 -----------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------------
 */
public:

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	MyDecoder()
	{
	};

	/*
	 ===============================================================================================================
	 ===============================================================================================================
	 */
	~MyDecoder()
	{
	};

	BOOL	DecodeLogin(const char *szVerifyCode, char *szAccount);

	BOOL	DecodeCharMove(const char *szVerifyCode, const GLPos *paTarPos, uint32 offset);

	BOOL	DecodeLockTarget(const char *szVerifyCode, ut_id_obj nTargetID, uint32 offset);

	BOOL	DecodeHeartBeat(const char *szVerifyCode, uint32 randNum, uint32 offset);

	BOOL	DecodeMD5PW(const char *szVerifyCode, char *szSource, int32 iSize, uint32 key);
};
#endif


// 快速的三角函数 [yangzhen]
class	MathSinCos
{
protected:
	static int	mTrigTableSize;
	static float	m_Trig_Table_Factor;
	static float	*mSinTable;

	void		buildTrigTables();
	static float	SinTable(float fValue);
public:
	static inline float Cos(const float &fValue) {	return SinTable(fValue + __HALF_PI); }
	static inline float Sin(const float &fValue) {	return SinTable(fValue); }

	MathSinCos(uint32 trigTableSize = 4096);
	~	MathSinCos();
};

extern MathSinCos	g_MathSinCos;

// md5编码器 [1/29/2015 yangzhen]
// a small class for calculating MD5 hashes of strings or byte arrays
// it is not meant to be fast or secure
//
// usage: 1) feed it blocks of uchars with update()
//      2) finalize()
//      3) get hexdigest() string
//      or
//      MD5(std::string).hexdigest()
//
// assumes that char is 8 bit and int is 32 bit
class MD5Encoder
{
public:
	typedef unsigned int size_type; // must be 32bit

	MD5Encoder();
	MD5Encoder(const std::string& text);
	MD5Encoder(const char* text, int len);
	void update(const unsigned char *buf, size_type length);
	void update(const char *buf, size_type length);
	MD5Encoder& finalize();
	std::string hexdigest() const;
	void hexdigest(char* output, int outlen) const;
	friend std::ostream& operator<<(std::ostream&, MD5Encoder md5);

private:
	void init();
	typedef unsigned char uint1; //  8bit
	typedef unsigned int uint4;  // 32bit
	enum {blocksize = 64}; // VC6 won't eat a const static int here

	void transform(const uint1 block[blocksize]);
	static void decode(uint4 output[], const uint1 input[], size_type len);
	static void encode(uint1 output[], const uint4 input[], size_type len);

	bool finalized;
	uint1 buffer[blocksize]; // bytes that didn't fit in last 64 byte chunk
	uint4 count[2];   // 64bit counter for number of bits (lo, hi)
	uint4 state[4];   // digest so far
	uint1 digest[16]; // the result

	// low level logic operations
	static inline uint4 F(uint4 x, uint4 y, uint4 z);
	static inline uint4 G(uint4 x, uint4 y, uint4 z);
	static inline uint4 H(uint4 x, uint4 y, uint4 z);
	static inline uint4 I(uint4 x, uint4 y, uint4 z);
	static inline uint4 rotate_left(uint4 x, int n);
	static inline void FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
	static inline void GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
	static inline void HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
	static inline void II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
};


// 检测非法字符 [xingzhishan]
extern char* CheckLawLessChar(char *pInStr, int32 nLen);
extern char* strlwr(char *pInStr, int32 nLen);
extern char* strupr(char *pInStr, int32 nLen);

extern BOOL UTF8ToGBK(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);
extern BOOL GBKToUTF8(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);
extern BOOL Big5ToGBK(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);
extern BOOL GBKToBig5(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);
extern BOOL Big5ToUTF8(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);
extern BOOL UTF8ToBig5(const char *inbuf, size_t inlen = 0, char *outbuf = NULL, size_t outlen = 0);

#if defined(__WINDOWS__)
//GBK编码转换到UTF8编码
extern BOOL WindowsGBKToUTF8(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
extern BOOL WindowsUTF8ToGBK(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
extern BOOL WindowsBig5ToGBK(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
extern BOOL WindowsGBKToBig5(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
extern BOOL WindowsBig5ToUTF8(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
extern BOOL WindowsUTF8ToBig5(const char *inbuf, size_t inlen, char *outbuf, size_t outlen);
#else
extern BOOL CodeConvert(const char *from_charset, const char *to_charset,const char *inbuf, size_t inlen,char *outbuf, size_t outlen); 
#endif

extern void createDir( const char* dir );


// 统一计算唯一id的方法 [ASSERT]
// nServerID 服务器id 16位 nType 玩法id 16位 nID 32 位
#pragma pack(1) 
struct  SUniqueIDInfo
{
	uint32 mID;
	uint16 mTypeID;
	uint16 mServerID;	
};

struct SUniqueID
{
	union 
	{
		int64 mSUniqueID;
		SUniqueIDInfo mSUniqueIDInfo;
	};
};
#pragma pack() 
uint64 GetUniqueID(uint16 nServerID, uint16 nType, uint32 nID);
SUniqueID GetUniqueIDStruct(uint64 uUniqueID);


#endif


